# Dubins Path Design: RSR (Right-Straight-Right) Trajectory

This repository contains a MATLAB script to design and visualize an RSR (Right-Straight-Right) Dubins path. The RSR path is a specific configuration of the Dubins path consisting of two circular arcs with a right turn and a straight line segment connecting them. The script calculates the trajectory between a given start and end point, ensuring that the vehicle adheres to a specific turning radius and heading angles at both points.

## Overview of the Process

The RSR Dubins path is designed to ensure the vehicle follows the shortest route while respecting its minimum turning radius. The process works as follows:

1. **Initialization**: Define the starting and ending points, as well as the heading angles and turning radius.
2. **Circle Centers Calculation**: Calculate the centers of the two circular arcs that the path will follow.
3. **Angle Calculation**: Determine the angles at which the circular arcs begin and end.
4. **Path Generation**: Compute the x and y coordinates for the circular arcs and the straight-line segment connecting them.
5. **Trajectory Visualization**: Plot the Dubins path, including the circular arcs, straight line, and direction arrows to show the movement.

The result is a clear visualization of the Dubins path, showing the start and end points, the circular arcs, and the straight line connecting them.

## Parameters

The script uses the following parameters to define the Dubins path:

- `start_point_x`, `start_point_y`: Coordinates of the starting point.
- `alpha_1`: Heading angle at the starting point (in radians).
- `R`: Turning radius (minimum radius of the circular arcs).
- `alpha_2`: Heading angle at the ending point (in radians).
- `end_point_x`, `end_point_y`: Coordinates of the end point.

These parameters can be adjusted to create different Dubins paths for various starting and ending configurations.

## Code Breakdown

1. **Circle Centers Calculation**: 
   - The center of the first circle is computed based on the starting point and heading angle.
   - The center of the second circle is computed similarly for the end point and heading angle.

2. **Angular Values for Arcs**:
   - The angular values for each circular arc are computed to ensure a clockwise motion.
   - The arc's start and end angles are determined by the relative positions of the circles and the desired motion direction.

3. **Path Calculation**:
   - The coordinates for the arc segments are generated by using parametric equations of the circle.
   - The straight-line segment is drawn connecting the end of the first arc and the beginning of the second arc.

4. **Plotting**:
   - The centers of the circles are marked in red.
   - The trajectory arcs are shown in blue.
   - The start and end points are marked in green.
   - Direction arrows are plotted along the trajectory to indicate the vehicle's motion.

## Usage

To use the code, simply copy the script into a MATLAB file (e.g., `dubins_path.m`) and execute it. The script will generate a plot showing the Dubins path trajectory.

### Example:
```matlab
% Parameters
start_point_x = 1;         % Starting point x-coordinate
start_point_y = 0;         % Starting point y-coordinate
alpha_1 = deg2rad(135);      % Starting heading angle in radians
R = 0.2;                     % Radius of the circle
alpha_2 = deg2rad(200);      % Ending heading angle in radians
end_point_x=2; 
end_point_y=2;

% Calculate the center of the circle based on the starting point and alpha
first_circle_x = start_point_x + R * cos(alpha_1 - pi/2);
first_circle_y = start_point_y + R * sin(alpha_1 - pi/2);
% Calculate the center of the second circle based on the end point and alpha
second_circle_x = end_point_x - R * cos(alpha_2+ pi/2);
second_circle_y = end_point_y - R * sin(alpha_2+pi/2);
d=sqrt((second_circle_y-first_circle_y)^2 +(second_circle_x-first_circle_x)^2);
gamma=atan2(second_circle_y-first_circle_y , second_circle_x-first_circle_x);
% Generate the theta values to ensure clockwise movement
if alpha_1 > gamma
    % If alpha is greater than beta, we can go directly from alpha to beta clockwise
    first_arc_theta_values = linspace(alpha_1, gamma, 100); 
else
    % Otherwise, we wrap around to create a full clockwise path
    first_arc_theta_values = linspace(alpha_1, gamma - 2*pi, 100); 
end
% Calculate x and y coordinates for the arc path
first_arc_x_values = first_circle_x + R * cos(first_arc_theta_values+pi/2);
first_arc_y_values = first_circle_y + R * sin(first_arc_theta_values+pi/2);
% Generate the theta values to ensure clockwise movement
if gamma>alpha_2
    % If gamma is greater than alpha_2, we can go directly from alpha to beta clockwise
    second_arc_theta_values = linspace( gamma,alpha_2, 100); 
else
    % Otherwise, we wrap around to create a full clockwise path
    second_arc_theta_values = linspace(gamma,alpha_2-2*pi, 100); 
end


% Calculate x and y coordinates for the arc path
second_arc_x_values = second_circle_x - R * cos(second_arc_theta_values-pi/2);
second_arc_y_values =second_circle_y - R * sin(second_arc_theta_values-pi/2);

% Plot the arc path
figure;
hold on;grid minor
plot(first_circle_x, first_circle_y, 'ro', 'MarkerSize', 8, 'DisplayName', 'Center'); % Circle center
plot(start_point_x, start_point_y, 'go', 'MarkerSize', 8, 'DisplayName', 'Start Point'); % Start point
plot(first_arc_x_values, first_arc_y_values, 'b-', 'LineWidth', 1.5, 'DisplayName', 'Trajectory Arc'); % Arc trajectory
plot(second_circle_x, second_circle_y, 'ro', 'MarkerSize', 8, 'DisplayName', 'Center'); % Circle center
plot(second_arc_x_values, second_arc_y_values, 'b-', 'LineWidth', 1.5, 'DisplayName', 'Trajectory Arc'); % Arc trajectory
plot(end_point_x, end_point_y, 'go', 'MarkerSize', 8, 'DisplayName', 'Start Point'); % Start point
line_start=[first_arc_x_values(end),second_arc_x_values(1)];
line_end=[first_arc_y_values(end),second_arc_y_values(1)];
line(line_start,line_end);
% Add direction arrows along the arc to show changing direction
arrow_skip = 5;  % Number of points to skip between arrows
for i = 1:arrow_skip:length(first_arc_theta_values)
    % Arrow position
    first_arrow_x = first_arc_x_values(i);
    first_arrow_y = first_arc_y_values(i);
    
    % Tangent direction at this point (perpendicular to radius)
    % tangent_angle = theta_values(i) - pi/2; % Adjust tangent angle for clockwise direction
    first_tangent_angle = first_arc_theta_values(i); % Adjust tangent angle for clockwise direction
    first_arrow_dx = cos(first_tangent_angle);
    first_arrow_dy = sin(first_tangent_angle);
    
    % Plot arrow showing the direction of motion
    quiver(first_arrow_x, first_arrow_y, first_arrow_dx, first_arrow_dy, 0.1, 'MaxHeadSize', 0.5, 'Color', 'red');
end

for i = 1:arrow_skip:length(second_arc_theta_values)
    % Arrow position
    second_arrow_x = second_arc_x_values(i);
    second_arrow_y = second_arc_y_values(i);
    
    % Tangent direction at this point (perpendicular to radius)
    % tangent_angle = theta_values(i) - pi/2; % Adjust tangent angle for clockwise direction
    second_tangent_angle = second_arc_theta_values(i); % Adjust tangent angle for clockwise direction
    second_arrow_dx = cos(second_tangent_angle);
   second_arrow_dy = sin(second_tangent_angle);
    
    % Plot arrow showing the direction of motion
    quiver(second_arrow_x, second_arrow_y, second_arrow_dx, second_arrow_dy, 0.1, 'MaxHeadSize', 0.5, 'Color', 'red');
end
xlabel('X');
ylabel('Y');
axis equal;
legend('show');
title('Clockwise Circular Arc Trajectory from Start Point');
hold off;

